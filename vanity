#! /usr/bin/env php
<?php
/********************************************************/
// PREPARATION

if (php_sapi_name() != 'cli') {
	die('Must run from command line');
}

$start_time = time();
error_reporting(-1);

ini_set('display_errors', 1);
ini_set('log_errors', 0);
ini_set('html_errors', 0);

define('VERSION', '2.0');
define('TAB', '    ');
define('VANITY_DIR', dirname(__FILE__) . DIRECTORY_SEPARATOR);
define('VANITY_CACHE_DIR', VANITY_DIR . 'cache' . DIRECTORY_SEPARATOR);
define('PHPREF_DIR', VANITY_CACHE_DIR . 'php' . DIRECTORY_SEPARATOR);
define('ENTITY_GLOBAL_DIR', VANITY_CACHE_DIR . 'entities' . DIRECTORY_SEPARATOR);
define('ENTITY_LANG_DIR', VANITY_CACHE_DIR . 'language-entities' . DIRECTORY_SEPARATOR);
define('WORKING_DIR', getcwd() . DIRECTORY_SEPARATOR);
define('CONFIG_DIR', WORKING_DIR . '_vanity' . DIRECTORY_SEPARATOR);
define('PARTIALS_DIR', WORKING_DIR . 'partials' . DIRECTORY_SEPARATOR);


/********************************************************/
// INCLUDES

include 'lib/cachecore/icachecore.interface.php';
include 'lib/cachecore/cachecore.class.php';
include 'lib/cachecore/cachefile.class.php';
include 'lib/DocumentingReflectionMethod/DocumentingReflectionMethod.inc.php';
include 'lib/example.class.php';
include 'lib/examplify.class.php';
include 'lib/generator.class.php';
include 'lib/lexer.class.php';
include 'lib/linkmap.class.php';
include 'lib/markdown.php';
include 'lib/phpt.class.php';
include 'lib/spyc.php';
include 'lib/utilities.class.php';


/********************************************************/
// GENERATE HELP

$help = array(
	'match:' => '(Required; Optional if defined in config) The file pattern to recursively match. Defaults to *.php.',
	'title:' => '(Required; Optional if defined in config) The title to use for the README page.',

	'exclude-access:' => '(Optional) Access types to exclude. Use this option multiple times to set multiple values. (e.g., public, protected, private)',
	'exclude-classes:' => '(Optional) The classname pattern to exclude. Use this option multiple times to set multiple values.',

	'cache:' => '(Optional) The location to use for cache files. Set to `false` to disable caching.',
	'output:' => '(Optional) The location to output the raw XML lexer output. Defaults to `output`.',
	'readme:' => '(Optional) The location of the file to use for the body of the README. Will be parsed with Markdown. Uses built-in default README if not set.',
	'template:' => '(Optional) The location of the directory that contains your `template_definition.php` file. Defaults to `template`.',

	'skip-update' => '(Optional) Skips the attempt to update the internal PHP reference from Subversion.',
	'skip-lexer' => '(Optional) Skips the lexer & reflection engine. Assumes that the XML output is already available to generate docs from.',
	'fresh' => '(Optional) Delete any existing cache files before processing so that the generation is fresh.',

	'help' => 'This help documentation.',
	'version' => 'The version number.',
);

$console_options = getopt('', array_keys($help));

if (isset($console_options['version']))
{
	echo 'Vanity ' . VERSION . PHP_EOL;
	die();
}
elseif (isset($console_options['help']))
{
	echo PHP_EOL;
	echo 'Vanity ' . VERSION . ' by Ryan Parman <http://ryanparman.com>' . PHP_EOL;
	echo TAB . "API reference generator for PHP." . PHP_EOL;
	echo PHP_EOL;

	ksort($help);

	foreach ($help as $k => $v)
	{
		echo '--' . preg_replace('/(:*)/', '', $k) . PHP_EOL;
		echo TAB . TAB . $v . PHP_EOL;
	}

	echo PHP_EOL . PHP_EOL;

	die();
}

echo PHP_EOL;
echo 'Vanity ' . VERSION . ' by Ryan Parman <http://ryanparman.com>' . PHP_EOL;
echo PHP_EOL;


/********************************************************/
// DEFAULT VALUES

// Defaults
$OPTIONS = $default_options = array(
	'exclude-access' => array('private'),
	'match' => '*.php',
	'output' => './output',
	'readme' => 'README.md',
	'template' => './templates/sdoc',
	'title' => 'Documentation',
);

// Create CONFIG_DIR if it doesn't exist.
if (realpath(CONFIG_DIR) == '')
{
	shell_exec('mkdir -p ' . CONFIG_DIR);
	file_put_contents(CONFIG_DIR . 'README.txt', 'This is a special directory used by Vanity to read custom configurations, or to use for caching and other features.' . PHP_EOL . PHP_EOL . 'See https://github.com/skyzyx/vanity/wiki for more information.');
}

// Config file options
if (file_exists(CONFIG_DIR . 'config.yml'))
{
	echo TAB . 'Merged configuration options from ' . CONFIG_DIR . 'config.yml' . PHP_EOL;
	$config_options = spyc_load_file(CONFIG_DIR . 'config.yml');
	$OPTIONS = array_merge($OPTIONS, $config_options);
}

// Console triggers
if (isset($console_options) && count($console_options) > 0)
{
	echo TAB . 'Merged configuration options from the console.' . PHP_EOL;
	$OPTIONS = array_merge($OPTIONS, $console_options);
}
echo PHP_EOL;


/********************************************************/
// NORMALIZE PATHS

if (isset($OPTIONS['cache']))
{
	if (strpos($OPTIONS['cache'], '/') !== 0)
	{
		$OPTIONS['cache'] = Util::normalize_path(CONFIG_DIR . $OPTIONS['cache']);
	}
}

if (isset($OPTIONS['output']))
{
	if (strpos($OPTIONS['output'], '/') !== 0)
	{
		$OPTIONS['output'] = Util::normalize_path(CONFIG_DIR . $OPTIONS['output']);
	}
}

if (isset($OPTIONS['template']))
{
	if (strpos($OPTIONS['template'], '/') !== 0)
	{
		$OPTIONS['template'] = Util::normalize_path(VANITY_DIR . $OPTIONS['template']);
	}
}

if (isset($OPTIONS['fresh']))
{
	$OPTIONS['fresh'] = true;
}

if (isset($OPTIONS['skip-lexer']))
{
	$OPTIONS['skip-lexer'] = true;
}

if (isset($OPTIONS['skip-update']))
{
	$OPTIONS['skip-update'] = true;
}

ksort($OPTIONS);
echo 'ACTIVE CONFIGURATION OPTIONS' . PHP_EOL;
echo Util::indent(Spyc::YAMLDump($OPTIONS)) . PHP_EOL;


/********************************************************/
// PULL PHP REFERENCE FROM SUBVERSION

if (isset($OPTIONS['skip-update']) && $OPTIONS['skip-update'] === true)
{
	echo 'UPDATING INTERNAL PHP REFERENCE' . PHP_EOL;
	echo TAB . 'Skipped.' . PHP_EOL;
	echo PHP_EOL;
}
else
{
	if (realpath(VANITY_CACHE_DIR) == '')
	{
		shell_exec('mkdir -p ' . VANITY_CACHE_DIR);
	}

	if (realpath(PHPREF_DIR) == '' || realpath(ENTITY_GLOBAL_DIR) == '' || realpath(ENTITY_LANG_DIR) == '')
	{
		echo 'DOWNLOADING INTERNAL PHP REFERENCE FOR THE FIRST TIME (THIS MIGHT TAKE A FEW MINUTES)' . PHP_EOL;
		echo Util::indent(shell_exec('svn co http://svn.php.net/repository/phpdoc/en/trunk/reference/ ' . PHPREF_DIR));
		echo Util::indent(shell_exec('svn co http://svn.php.net/repository/phpdoc/doc-base/trunk/entities/ ' . ENTITY_GLOBAL_DIR));
		echo Util::indent(shell_exec('svn co http://svn.php.net/repository/phpdoc/en/trunk/ ' . ENTITY_LANG_DIR . ' --depth files'));
	}
	else
	{
		echo 'UPDATING INTERNAL PHP REFERENCE' . PHP_EOL;
		echo Util::indent(shell_exec('svn up ' . PHPREF_DIR));
		echo Util::indent(shell_exec('svn up ' . ENTITY_GLOBAL_DIR));
		echo Util::indent(shell_exec('svn up ' . ENTITY_LANG_DIR));
	}
	echo PHP_EOL;
}


/********************************************************/
// GENERATE ENTITY MAP FOR PHP DOC REPLACEMENTS

echo 'GENERATING ENTITY MAP' . PHP_EOL;
$ENTITY_MAP = Util::generate_entity_map();
echo TAB . count($ENTITY_MAP) . ' entities mapped.' . PHP_EOL;
echo PHP_EOL;


/********************************************************/
// INDEXING PARTIALS

if (realpath(PARTIALS_DIR) != '')
{
	echo 'INDEXING PARTIALS' . PHP_EOL;
	$ENTITY_MAP = Util::generate_entity_map();
	echo TAB . count($ENTITY_MAP) . ' entities mapped.' . PHP_EOL;
	echo PHP_EOL;
}


/********************************************************/
// WORKING DIRECTORIES

echo 'WORKING DIRECTORIES' . PHP_EOL;

// Cache
if (isset($OPTIONS['cache']))
{
	if (realpath($OPTIONS['cache']) == '')
	{
		shell_exec('mkdir -p ' . $OPTIONS['cache']);
	}
	define('CACHE_DIR', realpath($OPTIONS['cache']) . DIRECTORY_SEPARATOR);
	echo TAB . 'Cache: ' . CACHE_DIR . PHP_EOL;
}

// Output
if (realpath($OPTIONS['output']) == '')
{
	shell_exec('mkdir -p ' . $OPTIONS['output']);
}
define('OUTPUT_DIR', realpath($OPTIONS['output']) . DIRECTORY_SEPARATOR);
define('HTML_DIR', OUTPUT_DIR . 'html' . DIRECTORY_SEPARATOR);
echo TAB . 'Output: ' . OUTPUT_DIR . PHP_EOL;

// Template
if (realpath($OPTIONS['template']) == '')
{
	// echo PHP_EOL . 'FATAL: The requested template directory does not exist.' . PHP_EOL . PHP_EOL;
	// die();
}
define('TEMPLATE_DIR', $OPTIONS['template'] . DIRECTORY_SEPARATOR);
echo TAB . 'Template: ' . TEMPLATE_DIR . PHP_EOL;

// README

// PHP REFERENCE
echo TAB . 'PHP Ref: ' . PHPREF_DIR . PHP_EOL;

echo PHP_EOL;


/********************************************************/
// DETERMINE CLASSES TO REFLECT

// Get the initial set of defined classes
$before = get_declared_classes();

// Glob and load
$files = Util::rglob($OPTIONS['match']);
echo "FILE MATCHES" . PHP_EOL;
foreach ($files as $file)
{
	$file = getcwd() . '/' . $file;
	echo TAB . $file . PHP_EOL;
	include_once $file;
}
echo PHP_EOL;

// Get the updated list of defined classes
$after = get_declared_classes();

// These are the new classes that were introduced
$diff = array_diff($after, $before);

// Do more filtering of the list
echo "CLASS MATCHES" . PHP_EOL;
$parse_me = array();
foreach ($diff as $class)
{
	$add = true;

	if (isset($OPTIONS['exclude-classes']))
	{
		foreach ($OPTIONS['exclude-classes'] as $exclusion)
		{
			if (preg_match('/' . $exclusion . '/', $class))
			{
				$add = false;
			}
		}
	}

	if ($add)
	{
		$parse_me[] = $class;
		echo TAB . $class . PHP_EOL;
	}
}

echo PHP_EOL;


/********************************************************/
// REMOVING OLD OUTPUT DIRECTORY

echo "REMOVING OLD OUTPUT DIRECTORY" . PHP_EOL;
if (OUTPUT_DIR == '/') die('Current working directory doesn\'t exist. Stopping.');
$cmd = 'rm -Rf ' . OUTPUT_DIR;
echo TAB . $cmd . PHP_EOL;
shell_exec($cmd);
echo PHP_EOL;


/********************************************************/
// GENERATING THE LINKMAP

echo "GENERATING THE LINKMAP" . PHP_EOL;
$lmap = new LinkMap();
foreach ($parse_me as $class)
{
	$lmap->add_class($class);
}
$LINKMAP = $lmap->generate_map();
echo TAB . 'Done.' . PHP_EOL;
echo PHP_EOL;


/********************************************************/
// RUN THE LEXER

echo "RUNNING THE LEXER" . PHP_EOL;
$lexer = new Lexer($LINKMAP);
foreach ($parse_me as $class)
{
	$lexer->parse_class($class, OUTPUT_DIR);
}
echo PHP_EOL;


/********************************************************/
// DONE

$end_time = time();
echo 'DONE. (' . Util::time_hms($end_time - $start_time) . ')' . PHP_EOL;
echo PHP_EOL;
