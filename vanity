#! /usr/bin/env php
<?php
/********************************************************/
// PREPARATION

if (php_sapi_name() !== 'cli') {
	die('Must run from command line');
}

$start_time = time();
error_reporting(-1);

ini_set('display_errors', 1);
ini_set('log_errors', 0);
ini_set('html_errors', 0);

define('VERSION', '2.0');
define('TAB', '    ');
define('VANITY_DIR', dirname(__FILE__) . DIRECTORY_SEPARATOR);
define('VANITY_CACHE_DIR', 'cache' . DIRECTORY_SEPARATOR);
define('PHPREF_DIR', VANITY_CACHE_DIR . 'php' . DIRECTORY_SEPARATOR);
define('ENTITY_GLOBAL_DIR', VANITY_CACHE_DIR . 'entities' . DIRECTORY_SEPARATOR);
define('ENTITY_LANG_DIR', VANITY_CACHE_DIR . 'language-entities' . DIRECTORY_SEPARATOR);
define('WORKING_DIR', getcwd() . DIRECTORY_SEPARATOR);
define('CONFIG_DIR', WORKING_DIR . '_vanity' . DIRECTORY_SEPARATOR);
define('PARTIALS_DIR', CONFIG_DIR . 'partials' . DIRECTORY_SEPARATOR);


/********************************************************/
// INCLUDES

include 'lib/cachecore/icachecore.interface.php';
include 'lib/cachecore/cachecore.class.php';
include 'lib/cachecore/cachefile.class.php';
include 'lib/DocumentingReflectionMethod/DocumentingReflectionMethod.inc.php';
include 'lib/example.class.php';
include 'lib/examplify.class.php';
include 'lib/filesystem.class.php';
include 'lib/generator.class.php';
include 'lib/lexer.class.php';
include 'lib/linkmap.class.php';
include 'lib/markdown.php';
include 'lib/phpt.class.php';
include 'lib/smartypants.php';
include 'lib/spyc.php';
include 'lib/templatexml.class.php';
include 'lib/utilities.class.php';


/********************************************************/
// GENERATE HELP

$help = array(
	'match:' => '(Required; Optional if defined in config) The file pattern to recursively match. Defaults to *.php.',

	'product-name:' => '(Required; Optional if defined in config) The product name to use for the README page.',
	'product-version:' => '(Required; Optional if defined in config) The product version to use for the README page.',

	'exclude-access:' => '(Optional) Access types to exclude. Use this option multiple times to set multiple values. (e.g., public, protected, private)',
	'exclude-classes:' => '(Optional) The classname pattern to exclude. Use this option multiple times to set multiple values.',
	'exclude-methods:' => '(Optional) The method name pattern to exclude. Use this option multiple times to set multiple values.',

	// 'cache:' => '(Optional) The location to use for cache files. Set to `false` to disable caching.',
	'output:' => '(Optional) The location to output the raw XML lexer output. Defaults to `output`.',
	'readme:' => '(Optional) The location of the file to use for the body of the README. Will be parsed with Markdown. Uses built-in default README if not set.',
	'template:' => '(Optional) The location of the directory that contains your `template_definition.php` file. Defaults to `template`.',

	'github:' => '(Optional) If the project is hosted on GitHub (e.g., github.com/<username>/<projectname>), pass the <username>/<projectname> (e.g., skyzyx/vanity).',

	'skip-lexer' => '(Optional) Skips the lexer & reflection engine. Assumes that the XML output is already available to generate docs from.',
	'skip-update' => '(Optional) Skips the attempt to update the internal PHP reference from Subversion.',
	'skip-offline' => '(Optional) Skips the process of generating offline archives of documentation.',
	// 'fresh' => '(Optional) Delete any existing cache files before processing so that the generation is fresh.',

	'help' => 'This help documentation.',
	'version' => 'The version number.',
);

$console_options = getopt('', array_keys($help));

if (isset($console_options['version']))
{
	echo 'Vanity ' . VERSION . PHP_EOL;
	die();
}
elseif (isset($console_options['help']))
{
	echo PHP_EOL;
	echo 'Vanity ' . VERSION . ' by Ryan Parman <http://ryanparman.com>' . PHP_EOL;
	echo TAB . "API reference generator for PHP." . PHP_EOL;
	echo PHP_EOL;

	ksort($help);

	foreach ($help as $k => $v)
	{
		echo '--' . preg_replace('/(:*)/', '', $k) . PHP_EOL;
		echo TAB . TAB . $v . PHP_EOL;
	}

	echo PHP_EOL . PHP_EOL;

	die();
}

echo PHP_EOL;
echo 'Vanity ' . VERSION . ' by Ryan Parman <http://ryanparman.com>' . PHP_EOL;
echo PHP_EOL;


/********************************************************/
// DEFAULT VALUES

// Global storage mechanism
$STORAGE = array();

// Defaults
$OPTIONS = $default_options = array(
	'exclude-access' => array('private'),
	'exclude-methods' => array('__call', '__toString'),
	'match' => '*.php',
	'output' => './output',
	'readme' => 'README.md',
	'template' => 'sdoc2',
	'product-name' => 'Documentation',
);

// Filesystem objects
$vanitydir = new Vanity_Filesystem_Direct(VANITY_DIR);

try
{
	$configdir = new Vanity_Filesystem_Direct(CONFIG_DIR);
}
catch (Exception $e)
{
	// Create CONFIG_DIR if it doesn't exist.
	$configdir = new Vanity_Filesystem_Directory(CONFIG_DIR, true, true);
	$configdir->put_contents(
		'README.txt',
		'This is a special directory used by Vanity to read custom configurations, or to use for caching and other features.' . PHP_EOL . PHP_EOL . 'See https://github.com/skyzyx/vanity/wiki for more information.'
	);
}

// Config file options
if ($configdir->exists('config.yml'))
{
	echo TAB . 'Merged configuration options from ' . CONFIG_DIR . 'config.yml' . PHP_EOL;
	$config_options = spyc_load($configdir->get_contents('config.yml'));
	$OPTIONS = array_merge($OPTIONS, $config_options);
}

// Console triggers
if (isset($console_options) && count($console_options) > 0)
{
	echo TAB . 'Merged configuration options from the console.' . PHP_EOL;
	$OPTIONS = array_merge($OPTIONS, $console_options);
}
echo PHP_EOL;


/********************************************************/
// NORMALIZE PATHS

/*if (isset($OPTIONS['cache']))
{
	if (strpos($OPTIONS['cache'], '/') !== 0)
	{
		$OPTIONS['cache'] = Util::normalize_path(CONFIG_DIR . $OPTIONS['cache']);
	}
}

if (isset($OPTIONS['output']))
{
	if (strpos($OPTIONS['output'], '/') !== 0)
	{
		$OPTIONS['output'] = Util::normalize_path(CONFIG_DIR . $OPTIONS['output']);
	}
}*/

if (isset($OPTIONS['template']))
{
	if (strpos($OPTIONS['template'], '/') !== 0)
	{
		$OPTIONS['template'] = $vanitydir->realpath('templates/' . $OPTIONS['template']);
	}
}

if (isset($OPTIONS['fresh']))
{
	$OPTIONS['fresh'] = true;
}

if (isset($OPTIONS['skip-lexer']))
{
	$OPTIONS['skip-lexer'] = true;
}

if (isset($OPTIONS['skip-offline']))
{
	$OPTIONS['skip-offline'] = true;
}

if (isset($OPTIONS['skip-update']))
{
	$OPTIONS['skip-update'] = true;
}

ksort($OPTIONS);
echo 'ACTIVE CONFIGURATION OPTIONS' . PHP_EOL;
echo Util::indent(Spyc::YAMLDump($OPTIONS)) . PHP_EOL;

if (!$vanitydir->exists(VANITY_CACHE_DIR))
{
	$vanitydir->mkdir(VANITY_CACHE_DIR);
}
$vanitydir->put_contents(VANITY_CACHE_DIR . sha1(CONFIG_DIR) . '.options', serialize($OPTIONS));


/********************************************************/
// RETICULATING SPLINES

echo 'RETICULATING SPLINES' . PHP_EOL;
echo TAB . 'Done.' . PHP_EOL;
echo PHP_EOL;


/********************************************************/
// WORKING DIRECTORIES

echo 'WORKING DIRECTORIES' . PHP_EOL;

echo TAB . 'VANITY_DIR:        ' . VANITY_DIR . PHP_EOL;
echo TAB . 'VANITY_CACHE_DIR:  ' . $vanitydir->realpath(VANITY_CACHE_DIR) . PHP_EOL;

// Template
if (realpath($OPTIONS['template']) == '')
{
	echo PHP_EOL . 'FATAL: The requested template directory does not exist.' . PHP_EOL . PHP_EOL;
	die();
}
define('TEMPLATE_DIR', $OPTIONS['template'] . DIRECTORY_SEPARATOR);
echo TAB . 'TEMPLATE_DIR:      ' . TEMPLATE_DIR . PHP_EOL;

echo TAB . 'WORKING_DIR:       ' . WORKING_DIR . PHP_EOL;
echo TAB . 'CONFIG_DIR:        ' . CONFIG_DIR . PHP_EOL;


// Cache
if (isset($OPTIONS['cache']))
{
	if (!$configdir->exists($OPTIONS['cache']))
	{
		$configdir->mkdir($OPTIONS['cache'], true);
	}
	define('CACHE_DIR', $OPTIONS['cache']);
	echo TAB . 'CACHE_DIR:         ' . $configdir->realpath(CACHE_DIR) . PHP_EOL;
}

echo TAB . 'PARTIALS_DIR:      ' . PARTIALS_DIR . PHP_EOL;

// Output
define('OUTPUT_DIR', $OPTIONS['output'] . DIRECTORY_SEPARATOR);
if (!$configdir->exists(OUTPUT_DIR))
{
	$configdir->mkdir(OUTPUT_DIR, true);
}

define('HTML_DIR', OUTPUT_DIR . 'html' . DIRECTORY_SEPARATOR);
if (!$configdir->exists(HTML_DIR))
{
	$configdir->mkdir(HTML_DIR, true);
}

echo TAB . 'OUTPUT_DIR:        ' . $configdir->realpath(OUTPUT_DIR) . PHP_EOL;
echo TAB . 'HTML_DIR:          ' . $configdir->realpath(HTML_DIR) . PHP_EOL;

// README

echo PHP_EOL;


#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# START SKIPPING THE LEXER, IF REQUESTED
if (!isset($OPTIONS['skip-lexer']) || !$OPTIONS['skip-lexer']) {
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


/********************************************************/
// PULL PHP REFERENCE FROM SUBVERSION

if (isset($OPTIONS['skip-update']) && $OPTIONS['skip-update'] === true)
{
	echo 'UPDATING INTERNAL PHP REFERENCE' . PHP_EOL;
	echo TAB . 'Skipped.' . PHP_EOL;
	echo PHP_EOL;
}
else
{
	if (!$vanitydir->exists(VANITY_CACHE_DIR))
	{
		$vanitydir->mkdir(VANITY_CACHE_DIR, true);
	}

	if (!$vanitydir->exists(PHPREF_DIR) || !$vanitydir->exists(ENTITY_GLOBAL_DIR) || !$vanitydir->exists(ENTITY_LANG_DIR))
	{
		echo 'DOWNLOADING INTERNAL PHP REFERENCE FOR THE FIRST TIME (THIS MIGHT TAKE A FEW MINUTES)' . PHP_EOL;
		echo Util::indent(shell_exec('svn co http://svn.php.net/repository/phpdoc/en/trunk/reference/ ' . $vanitydir->path(PHPREF_DIR)));
		echo Util::indent(shell_exec('svn co http://svn.php.net/repository/phpdoc/doc-base/trunk/entities/ ' . $vanitydir->path(ENTITY_GLOBAL_DIR)));
		echo Util::indent(shell_exec('svn co http://svn.php.net/repository/phpdoc/en/trunk/ ' . $vanitydir->path(ENTITY_LANG_DIR) . ' --depth files'));
	}
	else
	{
		echo 'UPDATING INTERNAL PHP REFERENCE' . PHP_EOL;
		echo Util::indent(shell_exec('svn up ' . $vanitydir->realpath(PHPREF_DIR)));
		echo Util::indent(shell_exec('svn up ' . $vanitydir->realpath(ENTITY_GLOBAL_DIR)));
		echo Util::indent(shell_exec('svn up ' . $vanitydir->realpath(ENTITY_LANG_DIR)));
	}
	echo PHP_EOL;
}


/********************************************************/
// GENERATE ENTITY MAP FOR PHP DOC REPLACEMENTS

echo 'GENERATING ENTITY MAP' . PHP_EOL;
$ENTITY_MAP = Util::generate_entity_map();
echo TAB . count($ENTITY_MAP) . ' entities mapped.' . PHP_EOL;
echo PHP_EOL;


/********************************************************/
// INDEXING PARTIALS

$PARTIALS = array();
if (realpath(PARTIALS_DIR) != '')
{
	echo 'INDEXING PARTIALS' . PHP_EOL;
	$files = Util::rglob(PARTIALS_DIR . '**.*');
	$PARTIALS = Util::content_partials($files);
	echo TAB . count($files) . ' partial' . ((count($files) === 1) ? '' : 's') . ' indexed.' . PHP_EOL;
	echo PHP_EOL;
}


/********************************************************/
// DETERMINE CLASSES TO REFLECT

// Get the initial set of defined classes
$before = get_declared_classes();

// Glob and load
$files = Util::rglob($OPTIONS['match']);
echo "FILE MATCHES" . PHP_EOL;
foreach ($files as $file)
{
	$file = getcwd() . '/' . $file;
	echo TAB . $file . PHP_EOL;
	include_once $file;
}
echo PHP_EOL;

// Get the updated list of defined classes
$after = get_declared_classes();

// These are the new classes that were introduced
$diff = array_diff($after, $before);

// Do more filtering of the list
echo "CLASS MATCHES" . PHP_EOL;
$parse_me = array();
foreach ($diff as $class)
{
	$add = true;

	if (isset($OPTIONS['exclude-classes']))
	{
		if (is_string($OPTIONS['exclude-classes']))
		{
			$OPTIONS['exclude-classes'] = array($OPTIONS['exclude-classes']);
		}

		foreach ($OPTIONS['exclude-classes'] as $exclusion)
		{
			if (preg_match('/' . $exclusion . '/', $class))
			{
				$add = false;
			}
		}
	}

	if ($add)
	{
		$parse_me[] = $class;
		echo TAB . $class . PHP_EOL;
	}
}

echo PHP_EOL;


/********************************************************/
// REMOVING OLD OUTPUT DIRECTORY

echo "REMOVING OLD OUTPUT DIRECTORY" . PHP_EOL;
$configdir->rmdir(OUTPUT_DIR, true);
echo PHP_EOL;


/********************************************************/
// GENERATING THE LINKMAP

echo "GENERATING THE LINKMAP" . PHP_EOL;
$lmap = new Vanity_LinkMap();
foreach ($parse_me as $class)
{
	$lmap->add_class($class);
}
$LINKMAP = $lmap->generate_map();
$vanitydir->put_contents(VANITY_CACHE_DIR . sha1(CONFIG_DIR) . '.linkmap', serialize($LINKMAP));
echo TAB . 'Done.' . PHP_EOL;
echo PHP_EOL;


/********************************************************/
// RUN THE LEXER

echo "RUNNING THE LEXER" . PHP_EOL;
$lexer = new Vanity_Lexer();
foreach ($parse_me as $class)
{
	$lexer->parse_class($class, OUTPUT_DIR);
}
echo PHP_EOL;


/********************************************************/
// PERSIST STORAGE

$vanitydir->put_contents(VANITY_CACHE_DIR . sha1(CONFIG_DIR) . '.storage', serialize($STORAGE));


#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# STOP SKIPPING THE LEXER
} else {
	echo 'SKIPPING THE LEXER' . PHP_EOL . TAB . 'Skipped.' . PHP_EOL . PHP_EOL;
	echo "REMOVING OLD HTML OUTPUT DIRECTORY" . PHP_EOL;
	$configdir->rmdir(HTML_DIR, true);
	echo PHP_EOL;
}
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


/********************************************************/
// READ AND APPLY THE TEMPLATES

echo "RUNNING THE GENERATOR" . PHP_EOL;
include TEMPLATE_DIR . 'template_definition.php';
$files = $configdir->glob(OUTPUT_DIR . 'xml' . DIRECTORY_SEPARATOR . '*.xml');
foreach ($files as $file)
{
	$file = $configdir->realpath($file);
	$template = new Template($file);
}
$generated = Util::rglob(OUTPUT_DIR . 'html' . DIRECTORY_SEPARATOR . 'class' . DIRECTORY_SEPARATOR . '**.html');
echo TAB . 'Generated ' . count($generated) . ' files.' . PHP_EOL;
echo PHP_EOL;


/********************************************************/
// GENERATING MANIFESTS

echo "GENERATING MANIFEST FILES" . PHP_EOL;

// XML
$xml = simplexml_load_string('<?xml version="1.0" encoding="UTF-8"?><manifest xmlns="http://vanitydoc.org"></manifest>', 'Vanity_SimpleXMLExtended', LIBXML_NOCDATA);
$files = $configdir->glob(OUTPUT_DIR . 'xml' . DIRECTORY_SEPARATOR . '*.xml');
$xfiles = $xml->addChild('files');
foreach ($files as $file) { $xfiles->addChild('file', pathinfo($file, PATHINFO_BASENAME)); }

if (!$configdir->exists(OUTPUT_DIR . 'xml'))
{
	$configdir->mkdir(OUTPUT_DIR . 'xml');
}
$manifest = OUTPUT_DIR . 'xml' . DIRECTORY_SEPARATOR . 'manifest.xml';
$configdir->put_contents($manifest, $xml->asXML());
echo TAB . $manifest . PHP_EOL;

// JSON
$json = array('file' => array());
$files = $configdir->glob(OUTPUT_DIR . 'json' . DIRECTORY_SEPARATOR . '*.js');
foreach ($files as $file) { $json['file'][] = pathinfo($file, PATHINFO_BASENAME); }

if (!$configdir->exists(OUTPUT_DIR . 'json'))
{
	$configdir->mkdir(OUTPUT_DIR . 'json');
}
$manifest = OUTPUT_DIR . 'json' . DIRECTORY_SEPARATOR . 'manifest.js';
$configdir->put_contents($manifest, json_encode($json));
echo TAB . $manifest . PHP_EOL;

// Serialized PHP
$php = array('file' => array());
$files = $configdir->glob(OUTPUT_DIR . 'php' . DIRECTORY_SEPARATOR . '*.php');
foreach ($files as $file) { $php['file'][] = pathinfo($file, PATHINFO_BASENAME); }

if (!$configdir->exists(OUTPUT_DIR . 'php'))
{
	$configdir->mkdir(OUTPUT_DIR . 'php');
}
$manifest = OUTPUT_DIR . 'php' . DIRECTORY_SEPARATOR . 'manifest.php';
$configdir->put_contents($manifest, serialize($php));
echo TAB . $manifest . PHP_EOL;

echo PHP_EOL;


/********************************************************/
// COPY STATIC FILES

echo "COPYING STATIC FILES TO OUTPUT DIRECTORY" . PHP_EOL;
Template::copy();
echo PHP_EOL;


/********************************************************/
// COPYING DOCUMENTATION FILES FROM PROJECT

echo "COPYING DOCUMENTATION FILES FROM PROJECT" . PHP_EOL;
if (!$configdir->exists(HTML_DIR . 'files' . DIRECTORY_SEPARATOR . 'included'))
{
	$configdir->mkdir(HTML_DIR . 'files' . DIRECTORY_SEPARATOR . 'included', true);
}
$template->files();
echo PHP_EOL;


/********************************************************/
// FIRE ANY LAST FUNCTIONALITY DEFINED BY THE TEMPLATE.

Template::fire_last();


/********************************************************/
// GENERATE OFFLINE DOCS

echo "GENERATING OFFLINE DOCS" . PHP_EOL;

if (isset($OPTIONS['skip-offline']) && $OPTIONS['skip-offline'])
{
	echo TAB . 'Skipped.' . PHP_EOL;
}
else
{
	$title = $GLOBALS['OPTIONS']['product-name'];
	$title .= isset($GLOBALS['OPTIONS']['product-version']) ? (' ' . $GLOBALS['OPTIONS']['product-version']) : '';
	$clean_title = strtolower(str_replace(array('(',')','|','/','\\'), '', str_replace(' ', '_', $title)));

	$cmd = 'cd ' . OUTPUT_DIR . ' && ' . PHP_EOL;
	$cmd .= 'cp -Rf ' . HTML_DIR . ' ' . OUTPUT_DIR . $clean_title . DIRECTORY_SEPARATOR . ' && ' . PHP_EOL;

	// zip
	$cmd .= 'zip -r latest_docs .' . DIRECTORY_SEPARATOR . $clean_title . DIRECTORY_SEPARATOR . PHP_EOL;
	$cmd .= 'mv latest_docs.zip ' . HTML_DIR . ' && ' . PHP_EOL;

	// gzip
	$cmd .= 'tar -cf latest_docs.tar .' . DIRECTORY_SEPARATOR . $clean_title . DIRECTORY_SEPARATOR . '* && gzip -9 latest_docs.tar && ' . PHP_EOL;
	$cmd .= 'mv latest_docs.tar.gz ' . HTML_DIR . ' && ' . PHP_EOL;

	// bzip2
	$cmd .= 'tar -cf latest_docs.tar .' . DIRECTORY_SEPARATOR . $clean_title . DIRECTORY_SEPARATOR . '* && bzip2 -9 latest_docs.tar && ' . PHP_EOL;
	$cmd .= 'mv latest_docs.tar.bz2 ' . HTML_DIR . ' && ' . PHP_EOL;

	$cmd .= 'rm -Rf ' . OUTPUT_DIR . $clean_title . DIRECTORY_SEPARATOR . PHP_EOL;
	//shell_exec($cmd);
	echo $cmd;

	// zip
	$doc_path = HTML_DIR . 'latest_docs.zip';
	echo TAB . $doc_path . ' (' . Util::size_readable(filesize($doc_path)) . ')' . PHP_EOL;

	// gzip
	$doc_path = HTML_DIR . 'latest_docs.tar.gz';
	echo TAB . $doc_path . ' (' . Util::size_readable(filesize($doc_path)) . ')' . PHP_EOL;

	// bzip2
	$doc_path = HTML_DIR . 'latest_docs.tar.bz2';
	echo TAB . $doc_path . ' (' . Util::size_readable(filesize($doc_path)) . ')' . PHP_EOL;
}

echo PHP_EOL;


/********************************************************/
// DONE

$end_time = time();
echo 'DONE. (' . Util::time_hms($end_time - $start_time) . ')' . PHP_EOL;
echo PHP_EOL;
